# 第五章 ByteBuf

主要内容

- ByteBuf —— Netty 的数据容器
- API 的详细信息
- 用例
- 内存分配

网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为的字节容器，但是这个类使用起来过于复杂，而且也是有些繁琐。

Netty 的 ByteBuffer 替代品是 ByteBuf，一个强大的实现，即解决了 JDK API 的局限性又为网络应用程序的开发者提供了更好的API。

5.1 ByteBuf 的 API

以下是 ByteBuf API 的一些优点

- 它可以被用户自定义的缓冲区类型扩展
- 通过内置的复合缓冲区类型实现了透明的零拷贝
- 容量可以按需增长（类似于 JDK 的 StringBuilder）
- 在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip() 方法
- 读和写使用了不同的索引
- 支持方法的链式调用
- 支持引用计数
- 支持池化

5.2 ByteBuf 类 —— Netty 的数据容器

因为所有的网络通信都涉及字节序列的移动，所以高效易用的数据结构明显是必不可少的。
Netty 的 ByteBuf 实现满足并超越了这些需求。

5.2.1 它是如何工作的

ByteBuf 维护了两个不同的索引：

一个用于读取，一个用于写入。

当你从 ByteBuf 读取时，它的 readerIndex 将会被递增已经被读取的字节数。

同样地，当你写入 ByteBuf 时，它的 writeIndex 也会被递增。


5.2.2 ByteBuf 的使用模式

1. 堆缓冲区

最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中

2. 直接缓冲区

直接缓冲区是另一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆中

3. 复合缓冲区

第三种也是最后一种模式使用的复合缓冲区，它为多个 ByteBuf 提供一个聚合视图。在这里你可以根据需要添加或者删除 ByteBuf 实例，这是一个 JDK 的 ByteBuffer 实现完全缺失的特性。

5.3 字节级操作

5.3.1 随机访问索引

5.3.2 顺序访问索引

5.3.3 可丢弃字节

5.3.4 可读字节

5.3.5 可写字节

5.3.6 索引管理

5.3.7 查找操作

5.3.8 派生缓冲区

5.3.9 读/写操作

5.3.10 更多的操作

5.4 ByteBufHolder 接口

5.5 ByteBuf 分配

5.5.1 按需分配：ByteBufAllocator 接口

5.5.2 Unpooled 缓冲区

5.5.3 ByteBufUtil 类

5.6 引用计数

5.7 小结

